// Generated by CoffeeScript 1.11.1
(function() {
  var Table, colors, commands, context, evalLines, myParse, name, nesh, options, program, reg, registers, registersString, registersTable, stty;

  nesh = require('nesh');

  Table = require('cli-table');

  colors = require('colors');

  program = require('commander');

  myParse = function(val) {
    return parseInt(val);
  };

  program.version('0.1.0').option('-b, --baudrate <n>', 'set AX12 communication baudrate (default 115200)', myParse, 115200).parse(process.argv);

  stty = require('child_process').spawn('stty', ['-F', '/dev/ttyS0', program.baudrate + '']);

  stty.stdout.on('data', function(data) {
    return console.log("stdout: " + data);
  });

  commands = new Table({
    chars: {
      'top': '',
      'top-mid': '',
      'top-left': '',
      'top-right': '',
      'bottom': '',
      'bottom-mid': '',
      'bottom-left': '',
      'bottom-right': '',
      'left': '',
      'left-mid': '',
      'mid': '',
      'mid-mid': '',
      'right': '',
      'right-mid': '',
      'middle': ' '
    },
    style: {
      'padding-left': 2,
      'padding-right': 0
    }
  });

  commands.push(['write'.red, '<ID>, <address>, <value>', 'write data in memory'], ['read'.red, '<ID>, <address>', 'read memory register'], ['dump'.red, '<ID>', 'dump the whole memory (EEPROM + RAM)'], ['status'.red, '<ID>', 'print the error flags'], ['scan()'.red, '', 'list all the connected AX12']);

  registers = {
    MODEL: {
      size: 16,
      write: false,
      address: 0x00
    },
    VERSION: {
      size: 8,
      write: false,
      address: 0x02
    },
    ID: {
      size: 8,
      write: true,
      address: 0x03
    },
    BAUDRATE: {
      size: 8,
      write: true,
      address: 0x04
    },
    RETURN_DELAY: {
      size: 8,
      write: true,
      address: 0x05
    },
    CW_LIMIT: {
      size: 16,
      write: true,
      address: 0x06
    },
    CCW_LIMIT: {
      size: 16,
      write: true,
      address: 0x08
    },
    MAX_TEMP: {
      size: 8,
      write: true,
      address: 0x0B
    },
    MIN_VOLTAGE: {
      size: 8,
      write: true,
      address: 0x0C
    },
    MAX_VOLTAGE: {
      size: 8,
      write: true,
      address: 0x0D
    },
    MAX_TORQUE_EE: {
      size: 16,
      write: true,
      address: 0x0E
    },
    RETURN_LEVEL: {
      size: 8,
      write: true,
      address: 0x10
    },
    ALARM_LED: {
      size: 8,
      write: true,
      address: 0x11
    },
    ALARM_SHUTDOWN: {
      size: 8,
      write: true,
      address: 0x12
    },
    TORQUE_ENABLE: {
      size: 8,
      write: true,
      address: 0x18
    },
    LED: {
      size: 8,
      write: true,
      address: 0x19
    },
    GOAL_POSITION: {
      size: 16,
      write: true,
      address: 0x1E
    },
    GOAL_SPEED: {
      size: 16,
      write: true,
      address: 0x20
    },
    MAX_TORQUE: {
      size: 16,
      write: true,
      address: 0x22
    },
    POSITION: {
      size: 16,
      write: false,
      address: 0x24
    },
    SPEED: {
      size: 16,
      write: false,
      address: 0x26
    },
    LOAD: {
      size: 16,
      write: false,
      address: 0x28
    },
    VOLTAGE: {
      size: 8,
      write: false,
      address: 0x2A
    },
    TEMPERATURE: {
      size: 8,
      write: false,
      address: 0x2B
    },
    MOVING: {
      size: 8,
      write: false,
      address: 0x2E
    },
    LOCK: {
      size: 8,
      write: true,
      address: 0x2F
    }
  };

  registersTable = new Table({
    chars: {
      'top': '',
      'top-mid': '',
      'top-left': '',
      'top-right': '',
      'bottom': '',
      'bottom-mid': '',
      'bottom-left': '',
      'bottom-right': '',
      'left': '',
      'left-mid': '',
      'mid': '',
      'mid-mid': '',
      'right': '',
      'right-mid': '',
      'middle': ' '
    },
    style: {
      'padding-left': 2,
      'padding-right': 0
    }
  });

  for (name in registers) {
    reg = registers[name];
    registersTable.push([('0x' + reg.address.toString(16).toUpperCase()).blue, name, reg.size, reg.write ? 'read/write' : 'read only'.red]);
  }

  context = function() {
    var __checkAddress, __checkID, comm, dump, read, scan, status, write;
    colors = require(__dirname + '/node_modules/colors');
    Table = require(__dirname + '/node_modules/cli-table');
    comm = require(__dirname + '/../AX12/ax-comm.js');
    comm.init(115200);
    __checkID = function(id) {
      if (!((0 <= id && id < 254))) {
        console.log('ERROR : Wrong ID (must be between 0 and 253)'.red);
      }
      return (0 <= id && id < 254);
    };
    __checkAddress = function(address) {
      var register;
      if (typeof address === 'number') {
        for (name in registers) {
          register = registers[name];
          if (register.address === address) {
            reg = register;
          }
        }
      } else if (typeof address === 'string' && (registers[address] != null)) {
        reg = registers[address];
      } else {
        console.log('ERROR : Wrong register'.red);
        return;
      }
      return reg;
    };
    write = function(id, address, value) {
      var result;
      if (!((0 <= id && id <= 254))) {
        console.log('ERROR : Wrong ID (must be between 0 and 253)'.red);
        return -1;
      }
      reg = __checkAddress(address);
      if (reg == null) {
        return -1;
      }
      if (!(typeof value === 'number' && !isNaN(value))) {
        console.log('ERROR : value must be a number'.red);
        return -1;
      }
      if (!reg.write) {
        console.log('ERROR : register #{address} is read-only'.red);
        return -1;
      }
      if (reg.size === 8) {
        result = comm.write8(id, reg.address, value);
      }
      if (reg.size === 16) {
        result = comm.write16(id, reg.address, value);
      }
      return result.code;
    };
    read = function(id, address) {
      var result;
      reg = __checkAddress(address);
      if (!((reg != null) && __checkID(id))) {
        return -1;
      }
      if (reg.size === 8) {
        result = comm.read8(id, reg.address);
      }
      if (reg.size === 16) {
        result = comm.read16(id, reg.address);
      }
      if (result.code < 0) {
        return result.code;
      } else {
        return result.value;
      }
    };
    dump = function(id) {
      var regsTable;
      if (!__checkID(id)) {
        return -1;
      }
      if (comm.ping(id).code < 0) {
        return "AX12 " + id + " not responding";
      }
      regsTable = new Table({
        chars: {
          'mid': '',
          'mid-mid': '',
          'left-mid': '',
          'right-mid': ''
        },
        style: {
          'padding-left': 2,
          'padding-right': 0
        },
        head: ['', 'name'.red, 'size'.red, 'value'.red]
      });
      regsTable.push(['', '', '', '']);
      for (name in registers) {
        reg = registers[name];
        regsTable.push([('0x' + reg.address.toString(16).toUpperCase()).blue, name, reg.size, read(id, name)]);
      }
      console.log(("\n          AX12 " + id + " memory dump").bold);
      console.log(regsTable.toString());
      return 0;
    };
    scan = function() {
      var ax12s, i, id;
      ax12s = [];
      comm.errorLog(false);
      for (id = i = 0; i <= 253; id = ++i) {
        if (comm.ping(id).code === 0) {
          ax12s.push(id);
        }
      }
      comm.errorLog(true);
      console.log("Found " + (ax12s.length + '').bold.blue + " AX12.");
      return ax12s;
    };
    status = function(id) {
      var result;
      if (!__checkID(id)) {
        return -1;
      }
      result = comm.ping(id);
      status = result.error.toString(2);
      while (status.length < 8) {
        status = '0' + status;
      }
      if (result.error & 0x40) {
        console.log('Instruction error flag set');
      }
      if (result.error & 0x20) {
        console.log('Overload error flag set');
      }
      if (result.error & 0x10) {
        console.log('Checksum error flag set');
      }
      if (result.error & 0x08) {
        console.log('Range error flag set');
      }
      if (result.error & 0x04) {
        console.log('Overheating error flag set');
      }
      if (result.error & 0x02) {
        console.log('Angle limit error flag set');
      }
      if (result.error & 0x01) {
        console.log('Input voltage error flag set');
      }
      if (result.code < 0) {
        return result.code;
      } else {
        return status;
      }
    };
    return 0;
  };

  registersString = 'registers = ' + JSON.stringify(registers) + '\n';

  for (name in registers) {
    reg = registers[name];
    registersString += name + " = '" + name + "'\n";
  }

  registersString += "__dirname = '" + __dirname + "'\n";

  evalLines = (context + '').split('\n');

  evalLines[0] = registersString;

  evalLines.pop();

  evalLines.pop();

  options = {
    welcome: "                         AX12 control console v1.0\nbaudrate : " + (program.baudrate + '').green + "\navailable commands :\n" + (commands.toString()) + "\nregister names :\n" + (registersTable.toString()),
    prompt: 'AX12> ',
    evalData: evalLines.join('\n')
  };

  nesh.loadLanguage('coffee');

  nesh.start(options, function(err) {
    if (err) {
      return nesh.log.error(err);
    }
  });

}).call(this);
